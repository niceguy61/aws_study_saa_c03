# 컨테이너 기술 개요

## 개요
컨테이너는 애플리케이션과 그 종속성을 함께 패키징하여 다양한 환경에서 일관되게 실행할 수 있게 해주는 경량 가상화 기술입니다. 이 강의에서는 컨테이너의 기본 개념, 작동 원리, 가상 머신과의 차이점, 그리고 클라우드 환경에서의 활용 방법을 알아봅니다.

## 학습 목표
- 컨테이너의 개념과 작동 원리 이해
- 컨테이너와 가상 머신의 차이점 학습
- Docker의 기본 개념 및 구성 요소 이해
- 컨테이너 이미지 생성 및 관리 방법 습득
- 컨테이너 오케스트레이션의 필요성 이해

## 컨테이너란 무엇인가?

### 기본 개념
컨테이너는 애플리케이션 코드와 모든 종속성(라이브러리, 바이너리, 구성 파일 등)을 포함하는 표준화된 소프트웨어 패키지입니다. 이를 통해 애플리케이션이 컴퓨팅 환경 간에 빠르고 안정적으로 실행될 수 있습니다.

**비유**: 컨테이너는 마치 해운 컨테이너와 같습니다. 해운 컨테이너가 화물을 안전하게 포장하여 다양한 운송 수단(선박, 트럭, 기차)을 통해 일관되게 운송할 수 있게 하는 것처럼, 소프트웨어 컨테이너는 애플리케이션을 다양한 환경(개발, 테스트, 프로덕션)에서 일관되게 실행할 수 있게 합니다.

### 컨테이너의 주요 특징

#### 1. 격리성
컨테이너는 호스트 시스템과 다른 컨테이너로부터 격리되어 실행됩니다.

**비유**: 이는 마치 아파트의 각 세대가 독립적인 생활 공간을 가지는 것과 같습니다. 각 세대는 같은 건물 내에 있지만 서로 간섭하지 않고 독립적으로 기능합니다.

#### 2. 경량성
컨테이너는 호스트 운영 체제의 커널을 공유하므로 가상 머신보다 훨씬 가볍습니다.

**비유**: 이는 마치 여러 애플리케이션이 같은 전기 시스템을 공유하는 것과 같습니다. 각 애플리케이션이 자체 발전기를 가질 필요 없이 공통 인프라를 활용합니다.

#### 3. 이식성
컨테이너는 어디서나 동일하게 실행될 수 있도록 모든 종속성을 포함합니다.

**비유**: 이는 마치 캠핑용 텐트와 같습니다. 필요한 모든 것이 포함되어 있어 어디에서든 설치하고 사용할 수 있습니다.

#### 4. 확장성
컨테이너는 빠르게 시작하고 중지할 수 있어 수요에 따라 쉽게 확장할 수 있습니다.

**비유**: 이는 마치 필요에 따라 쉽게 추가하거나 제거할 수 있는 모듈식 가구와 같습니다.

#### 5. 불변성
컨테이너 이미지는 빌드된 후에는 변경되지 않으며, 업데이트가 필요하면 새 이미지를 생성합니다.

**비유**: 이는 마치 사진과 같습니다. 한 번 찍힌 사진은 변경되지 않으며, 새로운 모습을 담고 싶다면 새 사진을 찍어야 합니다.

## 컨테이너 vs 가상 머신

### 아키텍처 비교

#### 가상 머신 아키텍처
```
+---------------------+  +---------------------+
|    애플리케이션     |  |    애플리케이션     |
+---------------------+  +---------------------+
|      바이너리       |  |      바이너리       |
+---------------------+  +---------------------+
|     게스트 OS       |  |     게스트 OS       |
+---------------------+  +---------------------+
|       하이퍼바이저        |
+---------------------+  +---------------------+
|           호스트 OS                |
+---------------------+  +---------------------+
|           인프라스트럭처            |
+---------------------+  +---------------------+
```

#### 컨테이너 아키텍처
```
+-------------+  +-------------+  +-------------+
|  애플리케이션 |  |  애플리케이션 |  |  애플리케이션 |
+-------------+  +-------------+  +-------------+
|   바이너리   |  |   바이너리   |  |   바이너리   |
+-------------+  +-------------+  +-------------+
|         컨테이너 런타임 (Docker 등)        |
+-------------------------------------------+
|               호스트 OS                   |
+-------------------------------------------+
|             인프라스트럭처                 |
+-------------------------------------------+
```

### 주요 차이점

#### 1. 리소스 효율성
- **가상 머신**: 각 VM은 완전한 OS를 실행하므로 더 많은 리소스(CPU, 메모리, 디스크)를 사용합니다.
- **컨테이너**: 호스트 OS 커널을 공유하므로 더 적은 리소스를 사용합니다.

**비유**: 가상 머신은 각각 자체 엔진을 가진 여러 대의 자동차와 같고, 컨테이너는 같은 엔진을 공유하는 여러 대의 오토바이와 같습니다.

#### 2. 시작 시간
- **가상 머신**: 전체 OS를 부팅해야 하므로 시작 시간이 길어집니다(수십 초~수 분).
- **컨테이너**: 프로세스를 시작하는 것과 유사하므로 시작 시간이 매우 짧습니다(수백 밀리초~수 초).

**비유**: 가상 머신은 자동차 시동을 거는 것과 같고, 컨테이너는 자전거를 타기 시작하는 것과 같습니다.

#### 3. 격리 수준
- **가상 머신**: 하드웨어 수준에서 완전히 격리되어 더 높은 보안을 제공합니다.
- **컨테이너**: 프로세스 수준에서 격리되어 약간 낮은 격리 수준을 제공합니다.

**비유**: 가상 머신은 각각 별도의 건물과 같고, 컨테이너는 같은 건물 내의 다른 방과 같습니다.

#### 4. 이미지 크기
- **가상 머신**: 전체 OS를 포함하므로 이미지 크기가 큽니다(수 GB).
- **컨테이너**: 애플리케이션과 종속성만 포함하므로 이미지 크기가 작습니다(수십~수백 MB).

**비유**: 가상 머신은 가득 찬 이삿짐 트럭과 같고, 컨테이너는 필수품만 담긴 배낭과 같습니다.

#### 5. 운영 체제 지원
- **가상 머신**: 호스트 OS와 다른 게스트 OS를 실행할 수 있습니다(예: Windows 호스트에서 Linux VM).
- **컨테이너**: 일반적으로 호스트 OS와 동일한 커널을 사용합니다(예: Linux 호스트에서는 Linux 컨테이너만 실행 가능).

**비유**: 가상 머신은 다양한 언어를 사용할 수 있는 다국적 회의와 같고, 컨테이너는 같은 언어를 사용하는 지역 모임과 같습니다.

## Docker 기본 개념

Docker는 컨테이너를 빌드, 실행 및 관리하기 위한 가장 인기 있는 플랫폼입니다.

### Docker의 주요 구성 요소

#### 1. Docker Engine
컨테이너를 생성하고 실행하는 핵심 소프트웨어입니다.

**구성 요소**:
- Docker 데몬(dockerd): 컨테이너 관리를 담당하는 백그라운드 서비스
- REST API: 데몬과 통신하기 위한 인터페이스
- CLI(Command Line Interface): 사용자가 Docker와 상호 작용하는 명령줄 도구

#### 2. Docker 이미지
컨테이너를 생성하기 위한 읽기 전용 템플릿입니다.

**특징**:
- 레이어 구조: 각 명령어가 새로운 레이어를 생성
- 캐싱: 빌드 프로세스 최적화
- 버전 관리: 태그를 통한 이미지 버전 관리
- 불변성: 빌드 후에는 변경 불가

**비유**: Docker 이미지는 마치 요리 레시피와 같습니다. 레시피는 요리를 만드는 방법을 정확히 설명하지만, 실제 요리는 아닙니다. 이미지는 컨테이너를 만드는 방법을 정의하지만, 실행 중인 컨테이너는 아닙니다.

#### 3. Dockerfile
Docker 이미지를 빌드하기 위한 지침이 포함된 텍스트 파일입니다.

**주요 명령어**:
- `FROM`: 기본 이미지 지정
- `RUN`: 명령 실행
- `COPY`/`ADD`: 파일 복사
- `WORKDIR`: 작업 디렉토리 설정
- `ENV`: 환경 변수 설정
- `EXPOSE`: 포트 노출
- `CMD`/`ENTRYPOINT`: 컨테이너 시작 시 실행할 명령 지정

**예시 Dockerfile**:
```dockerfile
FROM node:14
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

#### 4. Docker 컨테이너
Docker 이미지의 실행 가능한 인스턴스입니다.

**특징**:
- 격리된 프로세스
- 자체 파일 시스템
- 네트워크 인터페이스
- 리소스 제한 (CPU, 메모리 등)

**비유**: Docker 컨테이너는 마치 요리 레시피(이미지)로 만든 실제 요리와 같습니다. 같은 레시피로 여러 접시의 요리를 만들 수 있듯이, 하나의 이미지로 여러 컨테이너를 실행할 수 있습니다.

#### 5. Docker Registry
Docker 이미지를 저장하고 배포하는 저장소입니다.

**유형**:
- Docker Hub: 공식 공개 레지스트리
- Amazon ECR: AWS의 프라이빗 레지스트리
- Google Container Registry: Google Cloud의 프라이빗 레지스트리
- Azure Container Registry: Azure의 프라이빗 레지스트리
- 사설 레지스트리: 자체 호스팅 레지스트리

**비유**: Docker Registry는 마치 요리책 도서관과 같습니다. 다양한 요리 레시피(이미지)를 저장하고 공유할 수 있는 중앙 저장소입니다.

### Docker 기본 명령어

#### 이미지 관리
- `docker build`: Dockerfile에서 이미지 빌드
- `docker pull`: 레지스트리에서 이미지 다운로드
- `docker push`: 레지스트리에 이미지 업로드
- `docker images`: 로컬 이미지 목록 표시
- `docker rmi`: 이미지 삭제

#### 컨테이너 관리
- `docker run`: 새 컨테이너 생성 및 시작
- `docker start/stop/restart`: 컨테이너 시작/중지/재시작
- `docker ps`: 실행 중인 컨테이너 목록 표시
- `docker exec`: 실행 중인 컨테이너에서 명령 실행
- `docker logs`: 컨테이너 로그 확인
- `docker rm`: 컨테이너 삭제

#### 네트워크 및 볼륨
- `docker network`: 네트워크 생성 및 관리
- `docker volume`: 볼륨 생성 및 관리
- `docker-compose`: 다중 컨테이너 애플리케이션 정의 및 실행

## 컨테이너 이미지 생성 및 관리

### 이미지 레이어 이해하기

Docker 이미지는 여러 레이어로 구성되며, 각 레이어는 Dockerfile의 명령에 해당합니다.

```
+---------------------------+
|     애플리케이션 코드      | <- 최신 레이어
+---------------------------+
|     종속성 설치           |
+---------------------------+
|     설정 파일 복사        |
+---------------------------+
|     기본 이미지           | <- 기본 레이어
+---------------------------+
```

**장점**:
- 레이어 캐싱: 변경되지 않은 레이어는 재사용되어 빌드 시간 단축
- 스토리지 효율성: 여러 이미지가 동일한 레이어 공유
- 증분 배포: 변경된 레이어만 전송

**비유**: 이미지 레이어는 마치 투명한 오버레이 시트를 겹쳐 놓은 것과 같습니다. 각 시트는 이전 시트 위에 새로운 정보를 추가하며, 최종 이미지는 모든 시트를 함께 본 결과입니다.

### 효율적인 Dockerfile 작성 방법

#### 1. 적절한 기본 이미지 선택
- 공식 이미지 사용
- 특정 버전 태그 지정
- 가능한 작은 이미지 선택 (예: alpine 버전)

**예시**:
```dockerfile
# 좋음: 특정 버전의 경량 이미지 사용
FROM node:14-alpine

# 나쁨: 태그 없이 최신 버전 사용
FROM node:latest
```

#### 2. 레이어 최소화
- 관련 명령을 하나의 RUN 문으로 결합
- 불필요한 파일 제거

**예시**:
```dockerfile
# 좋음: 명령 체이닝
RUN apt-get update && \
    apt-get install -y package1 package2 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# 나쁨: 여러 RUN 명령 사용
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2
```

#### 3. 빌드 컨텍스트 최적화
- `.dockerignore` 파일 사용
- 필요한 파일만 포함

**예시 .dockerignore**:
```
node_modules
npm-debug.log
Dockerfile
.git
.gitignore
```

#### 4. 다단계 빌드 사용
빌드 단계와 실행 단계를 분리하여 최종 이미지 크기 축소

**예시**:
```dockerfile
# 빌드 단계
FROM node:14 AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 실행 단계
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 이미지 태깅 및 버전 관리

#### 태그 명명 규칙
- `name:tag` 형식 사용
- 의미 있는 태그 사용 (버전, 환경 등)

**예시**:
```
myapp:1.0.0          # 특정 버전
myapp:latest         # 최신 버전
myapp:1.0.0-alpine   # 특정 버전 및 기반 이미지
myapp:dev            # 개발 환경
myapp:prod           # 프로덕션 환경
```

#### 이미지 버전 관리 전략
- 시맨틱 버전 관리 (major.minor.patch)
- Git 커밋 해시 사용
- 빌드 날짜/시간 포함
- 환경별 태그 사용

**명령어 예시**:
```bash
# 이미지 빌드 및 태그 지정
docker build -t myapp:1.0.0 .
docker tag myapp:1.0.0 myregistry.com/myapp:1.0.0

# 이미지 푸시
docker push myregistry.com/myapp:1.0.0
```

### 이미지 보안 모범 사례

#### 1. 최소 권한 원칙
- 루트가 아닌 사용자로 실행
- 필요한 권한만 부여

**예시**:
```dockerfile
FROM node:14-alpine
# 비루트 사용자 생성
RUN addgroup -g 1000 appuser && \
    adduser -u 1000 -G appuser -s /bin/sh -D appuser
WORKDIR /app
COPY --chown=appuser:appuser . .
# 비루트 사용자로 전환
USER appuser
CMD ["node", "app.js"]
```

#### 2. 이미지 스캐닝
- 취약점 스캐닝 도구 사용 (Trivy, Clair, Snyk 등)
- CI/CD 파이프라인에 스캐닝 통합
- 정기적인 스캐닝 수행

#### 3. 비밀 관리
- Dockerfile에 비밀 정보 포함 금지
- 빌드 인수 또는 런타임 환경 변수 사용
- 비밀 관리 도구 활용 (AWS Secrets Manager, HashiCorp Vault 등)

**나쁜 예시**:
```dockerfile
# 절대 하지 말 것: Dockerfile에 비밀 정보 하드코딩
ENV API_KEY="my-secret-api-key"
```

**좋은 예시**:
```dockerfile
# 빌드 시 또는 런타임에 비밀 정보 제공
ARG API_KEY
ENV API_KEY=$API_KEY
```

## 컨테이너 오케스트레이션 소개

### 오케스트레이션의 필요성

단일 컨테이너를 관리하는 것은 간단하지만, 프로덕션 환경에서는 수십, 수백 또는 수천 개의 컨테이너를 관리해야 할 수 있습니다. 이때 컨테이너 오케스트레이션 도구가 필요합니다.

**주요 과제**:
- 컨테이너 배포 및 스케줄링
- 서비스 검색 및 로드 밸런싱
- 스케일링 및 자동 복구
- 구성 관리
- 보안 및 네트워킹
- 모니터링 및 로깅

**비유**: 컨테이너 오케스트레이션은 마치 오케스트라 지휘자와 같습니다. 각 악기(컨테이너)가 언제, 어떻게 연주해야 하는지 조정하여 전체 오케스트라(애플리케이션)가 조화롭게 작동하도록 합니다.

### 주요 오케스트레이션 도구

#### 1. Kubernetes
가장 인기 있는 오픈 소스 컨테이너 오케스트레이션 플랫폼입니다.

**주요 기능**:
- 선언적 구성
- 자동 스케일링
- 자동 복구
- 서비스 검색 및 로드 밸런싱
- 롤링 업데이트 및 롤백
- 스토리지 오케스트레이션
- 비밀 및 구성 관리

**AWS 관련 서비스**: Amazon EKS(Elastic Kubernetes Service)

#### 2. Docker Swarm
Docker의 기본 제공 오케스트레이션 도구입니다.

**주요 기능**:
- Docker와의 통합
- 간단한 설정 및 사용
- 서비스 확장 및 로드 밸런싱
- 롤링 업데이트
- 서비스 검색

#### 3. Amazon ECS (Elastic Container Service)
AWS의 완전 관리형 컨테이너 오케스트레이션 서비스입니다.

**주요 기능**:
- AWS 서비스와의 통합
- 서버리스 옵션 (Fargate)
- 자동 스케일링
- 로드 밸런싱
- 작업 스케줄링
- 보안 및 규정 준수

#### 4. AWS App Runner
컨테이너화된 애플리케이션을 위한 완전 관리형 서비스입니다.

**주요 기능**:
- 소스 코드 또는 컨테이너 이미지에서 직접 배포
- 자동 빌드 및 배포
- 자동 스케일링
- 로드 밸런싱
- 보안 및 암호화

### 컨테이너 오케스트레이션의 주요 개념

#### 1. 클러스터
컨테이너를 실행하는 노드(가상 머신 또는 물리적 서버)의 집합입니다.

**비유**: 클러스터는 마치 여러 대의 컴퓨터로 구성된 데이터 센터와 같습니다.

#### 2. 노드
컨테이너를 실행하는 개별 머신(가상 또는 물리적)입니다.

**유형**:
- 마스터 노드: 클러스터 관리
- 워커 노드: 컨테이너 실행

**비유**: 노드는 마치 개별 서버 컴퓨터와 같습니다.

#### 3. 포드(Pod)
Kubernetes에서 가장 작은 배포 단위로, 하나 이상의 컨테이너 그룹입니다.

**특징**:
- 동일한 네트워크 네임스페이스 공유
- 동일한 스토리지 볼륨 액세스
- 함께 스케줄링 및 배포

**비유**: 포드는 마치 아파트의 한 세대와 같습니다. 여러 방(컨테이너)이 있지만 같은 주소와 공용 공간을 공유합니다.

#### 4. 서비스
포드 집합에 대한 안정적인 네트워크 엔드포인트를 제공합니다.

**유형**:
- ClusterIP: 클러스터 내부 통신
- NodePort: 노드 포트를 통한 외부 액세스
- LoadBalancer: 외부 로드 밸런서를 통한 액세스
- ExternalName: 외부 서비스에 대한 별칭

**비유**: 서비스는 마치 호텔 프론트 데스크와 같습니다. 손님(요청)을 적절한 객실(포드)로 안내합니다.

#### 5. 배포(Deployment)
포드의 선언적 업데이트를 관리합니다.

**기능**:
- 롤링 업데이트
- 롤백
- 스케일링
- 자동 복구

**비유**: 배포는 마치 제품 출시 계획과 같습니다. 새 버전을 어떻게 출시하고, 문제가 있을 경우 어떻게 이전 버전으로 돌아갈지 정의합니다.

## AWS에서의 컨테이너 활용

### Amazon ECR (Elastic Container Registry)
Docker 컨테이너 이미지를 저장, 관리 및 배포하기 위한 완전 관리형 레지스트리 서비스입니다.

**주요 기능**:
- 이미지 스캐닝
- 이미지 버전 관리
- 액세스 제어
- 암호화
- 복제

**사용 사례**:
- 프라이빗 이미지 저장소
- CI/CD 파이프라인 통합
- 이미지 취약점 스캐닝

### Amazon ECS (Elastic Container Service)
컨테이너화된 애플리케이션을 쉽게 배포, 관리 및 확장할 수 있는 완전 관리형 컨테이너 오케스트레이션 서비스입니다.

**주요 구성 요소**:
- 클러스터: 컨테이너를 실행하는 인프라
- 작업 정의: 컨테이너 구성 (Docker 이미지, CPU, 메모리 등)
- 작업: 작업 정의의 인스턴스
- 서비스: 작업 집합을 관리하고 로드 밸런싱 제공

**시작 유형**:
- EC2: 사용자가 관리하는 EC2 인스턴스에서 컨테이너 실행
- Fargate: 서버리스 컨테이너 실행 (인프라 관리 불필요)

**사용 사례**:
- 마이크로서비스 아키텍처
- 배치 처리
- 웹 애플리케이션
- 장기 실행 서비스

### Amazon EKS (Elastic Kubernetes Service)
AWS에서 Kubernetes를 실행하기 위한 관리형 서비스입니다.

**주요 기능**:
- 관리형 Kubernetes 컨트롤 플레인
- 여러 가용 영역에 걸친 고가용성
- AWS 서비스와의 통합
- 보안 및 규정 준수

**시작 옵션**:
- EC2: 사용자가 관리하는 EC2 인스턴스에서 실행
- Fargate: 서버리스 컨테이너 실행

**사용 사례**:
- 복잡한 마이크로서비스 아키텍처
- 하이브리드 클라우드 배포
- 기존 Kubernetes 워크로드 마이그레이션

### AWS App Runner
소스 코드 또는 컨테이너 이미지에서 직접 확장 가능한 웹 애플리케이션을 배포하기 위한 완전 관리형 서비스입니다.

**주요 기능**:
- 자동 빌드 및 배포
- 자동 스케일링
- 로드 밸런싱
- 보안 및 암호화
- 지속적 배포

**사용 사례**:
- 웹 애플리케이션
- API
- 마이크로서비스
- 개발 및 테스트 환경

### AWS Fargate
서버를 관리하지 않고도 컨테이너를 실행할 수 있는 서버리스 컴퓨팅 엔진입니다.

**주요 기능**:
- 서버 관리 불필요
- 컨테이너 수준 격리
- 사용한 만큼만 지불
- ECS 및 EKS와 통합

**사용 사례**:
- 가변적인 워크로드
- 인프라 관리 오버헤드 최소화
- 비용 최적화

## 결론
컨테이너는 애플리케이션 개발, 배포 및 관리 방식을 혁신적으로 변화시켰습니다. 가상 머신보다 가볍고 효율적이며, 일관된 환경을 제공하여 "내 컴퓨터에서는 작동했는데" 문제를 해결합니다. Docker와 같은 도구를 사용하면 컨테이너를 쉽게 생성하고 관리할 수 있으며, Kubernetes, Amazon ECS, EKS와 같은 오케스트레이션 플랫폼을 통해 대규모 컨테이너 배포를 효과적으로 관리할 수 있습니다. AWS는 ECR, ECS, EKS, Fargate, App Runner 등 다양한 컨테이너 서비스를 제공하여 컨테이너화된 애플리케이션의 개발, 배포 및 운영을 지원합니다.

## 참고 자료
- [Docker 공식 문서](https://docs.docker.com/)
- [Kubernetes 공식 문서](https://kubernetes.io/docs/home/)
- [Amazon ECS 개발자 안내서](https://docs.aws.amazon.com/ecs/index.html)
- [Amazon EKS 사용 설명서](https://docs.aws.amazon.com/eks/index.html)
- [AWS Fargate 사용 설명서](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
- [AWS App Runner 개발자 안내서](https://docs.aws.amazon.com/apprunner/index.html)